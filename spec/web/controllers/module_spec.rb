require_relative '../../spec_helper'

describe Web::Controllers::Module do
  let(:app) { described_class }

  let(:module_can_execute?) { true }
  let(:module_dbl) do
    double(
      'module',
      module_name: 'name',
      module_desc: 'desc',
      module_references: [],
      module_author: [],
      module_date: '1970-01-01',
      options: [],
      can_execute?: module_can_execute?,
      payload: nil
    )
  end

  before(:each) do
    allow_any_instance_of(described_class)
      .to receive(:load_module)
      .and_return(module_dbl)
  end

  it_behaves_like 'a route controller'

  describe 'GET /:type/:name' do
    it 'returns the requested module, if it exists' do
      get '/auxiliary/test'

      json = JSON.parse(last_response.body)
      expect(json).to include(
        'title', 'desc', 'references', 'authors', 'date', 'options', 'path'
      )
    end

    it 'returns an empty body if :type !== exploit or auxiliary' do
      get '/invalid/invalid'
      expect(last_response.body).to eq ''
    end

    context 'when the module does not exist' do
      let(:module_dbl) { nil }
      it 'sets the response status to 404' do
        get '/auxiliary/test'
        expect(last_response.not_found?).to be true
      end
    end
  end

  describe 'POST /:type/:name' do
    it 'returns an empty body if :type !== exploit or auxiliary' do
      post '/invalid/invalid'
      expect(last_response.body).to eq ''
    end

    context 'when the module does not exist' do
      let(:module_dbl) { nil }
      it 'sets the response status to 404' do
        post '/auxiliary/test'
        expect(last_response.not_found?).to be true
      end
    end

    context 'when the module can execute' do
      it 'creates a new session and returns the id' do
        post '/auxiliary/test'
        json = JSON.parse(last_response.body)

        expect(json).to include('success', 'session_id')
        expect(json['success']).to be true

        session_id = json['session_id']
        session = Web::Models::Session.first(id: session_id)
        expect(session).not_to be_nil
      end
    end

    context 'when the module cannot execute' do
      let(:module_can_execute?) { false }

      it 'sets the response status to 500' do
        post '/auxiliary/test'
        expect(last_response.status).to eq 500
      end

      it 'sets the success property in the output to false' do
        post '/auxiliary/test'
        json = JSON.parse(last_response.body)
        expect(json['success']).to be false
      end
    end
  end
end
