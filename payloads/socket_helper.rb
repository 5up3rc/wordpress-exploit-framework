# Provides common functionality for socket based payloads.
module Wpxf::Payloads::SocketHelper
  def start_socket_io_loop(socket, event_emitter)
    self.socket_input_stream = context == :web ? StringIO.new : STDIN
    read_thread = Thread.new { start_socket_read_loop(socket, event_emitter) }
    execute_queued_commands(socket, event_emitter)
    start_socket_write_loop(socket, read_thread, event_emitter)
  rescue SignalException
    event_emitter.emit_socket_data "\n"
    event_emitter.emit_warning 'Caught kill signal', true
  rescue StandardError => e
    puts
    event_emitter.emit_error "Error encountered: #{e}"
  end

  def execute_queued_commands(socket, event_emitter)
    queued_commands.each do |cmd|
      socket.puts cmd
      event_emitter.emit_success "Executed: #{cmd}"
    end

    puts
  end

  def start_socket_write_loop(socket, read_thread, event_emitter)
    loop do
      if event_emitter.kill_requested?
        read_thread.exit
        break
      end

      input = socket_input_stream.gets
      if input.nil?
        Thread.pass
        next
      end

      if input =~ /^(quit|exit)$/i
        read_thread.exit
        break
      else
        socket.puts input
      end
    end
  end

  def start_socket_read_loop(socket, event_emitter)
    loop do
      begin
        event_emitter.emit_socket_data(socket.read_nonblock(1024))
      rescue IO::WaitReadable
        Thread.pass
        retry
      rescue StandardError => e
        raise 'Connection lost' if e.is_a? EOFError
        event_emitter.emit_socket_data "\nSOCKET ERROR: #{e}"
      end
    end
  end

  attr_accessor :socket_input_stream
end
